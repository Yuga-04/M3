## **Directed Acyclic Graph (DAG) Representation for Basic Blocks**

### **Definition**

A **Directed Acyclic Graph (DAG)** for a **basic block** is a graphical representation that shows the **computations of the block**, highlighting **dependencies** among variables and operations while avoiding redundant calculations.

It helps in identifying:

* **Common sub-expressions**
* **Dead code**
* **Optimization opportunities**

---

### **Structure of a DAG**

Each **node** in a DAG is labeled as follows:

1. **Leaves (Operands):**

   * Represent **unique identifiers** — either **variables** or **constants**.
     Example: `a`, `b`, `5`

2. **Interior Nodes (Operators):**

   * Represent **operators** like `+`, `–`, `*`, `/`.
   * Each operator node connects to its operand nodes.

3. **Result Labels:**

   * Nodes can have **labels** that represent the variables where the results are stored.

---

### **Purpose of DAG**

A DAG helps the compiler:

* Detect **common sub-expressions** automatically.
* Identify **values used** in the block.
* Determine **statements whose results** are used outside the block.
* Assist in **code generation** and **optimization**.

---

## **Steps for Constructing a DAG**

Given a **basic block** of three-address statements, the DAG is constructed as follows:

### **Algorithm Steps:**

1. **Input:**

   * A list of three-address statements (intermediate code).

2. **Process each statement `x := y op z`:**

   * Find or create nodes for operands `y` and `z`.
   * Check if an existing node with the same operator and operands already exists.
   * If yes, attach `x` as a label to that node.
   * If not, create a new node for `op` with `y` and `z` as children, label it with `x`.

3. **Handle assignments `x := y`:**

   * Link `x` to the same node as `y` (no new computation node is needed).

4. **Repeat until all statements are processed.**

---

### **Example**

**Three-address code:**

```
1. t1 := 4 * i  
2. t2 := a[t1]  
3. t3 := 4 * i  
4. t4 := b[t3]  
5. t5 := t2 * t4  
6. t6 := prod + t5  
7. prod := t6  
8. t7 := i + 1  
9. i := t7  
10. if i <= 20 goto (1)
```

---

### **DAG Construction Explanation**

* Node for `4` and `i` → Operator `*` → Node labeled `t1`
* Statement (3) computes `4 * i` again → already exists → **common subexpression detected** (no new node created).
* Nodes created for `a[t1]`, `b[t3]`, `t2 * t4`, and `prod + t5`.
* Each variable that stores a result becomes a label on the corresponding node.
* The result: a **DAG** showing computation flow and reuse of existing subexpressions.

---

### **Applications of DAGs**

1. **Common Subexpression Elimination** – Identify repeated expressions and compute them once.
2. **Dead Code Elimination** – Remove computations whose results are never used.
3. **Register Allocation** – Helps in determining which results can share the same register.
4. **Code Generation** – Guides efficient instruction order to minimize temporary variables.

---

### **Generating Code from DAG**

* Once DAG is built, code can be generated by **traversing nodes** in dependency order.
* **Reordering** computations can minimize register use and improve efficiency.

**Example DAG-based reorder:**

Original:

```
t1 := a + b
t2 := c + d
t3 := e - t2
t4 := t1 - t3
```

Reordered using DAG dependencies:

```
t2 := c + d
t3 := e - t2
t1 := a + b
t4 := t1 - t3
```

This reduces register load operations and makes execution faster.

---

### **Advantages of Using DAG**

* Eliminates redundant computations.
* Improves code efficiency and speed.
* Provides a clear visual structure of computation dependencies.
* Simplifies optimization and code generation.
